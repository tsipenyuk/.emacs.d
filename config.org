#+STARTUP: overview
#+TITLE: My Emacs Configuration
#+CREATOR: Arseniy Tsipenyuk
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;
* Source
This emacs configuration is based on [[https://github.com/daedreth/UncleDavesEmacs][UncleDavesEmacs]] repository and
adapted using various other sources.  Various things were adapted from
[[https://pages.sachachua.com/.emacs.d/Sacha.html][Sacha~Chua]]'s page.  I highly recommend you check these sources before
using my derivative version.
* Installation
Run =git clone https://github.com/tsipenyuk/.emacs.d ~/.emacs.d= .

Don't forget to back up your own ~/.emacs and your ~/.emacs.d prior to cloning this configuration.
For the first startup, I recommend launching emacs in the tty.

* Dependencies
I have copied the dependencies from the UncleDavesEmacs setup for future 
reference. As of yet, I am only using =exwm=, =xorg-server=, and trying to
get into =qutebrowser=.
* Personalize load-path etc.
Non-melpa packages are stored in =lisp= and =site-lisp=.
I am not certain whether I want to store anything in the =custom.el= at this point.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
  (add-to-list 'load-path (expand-file-name "site-lisp" user-emacs-directory))
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file t)

  (setq user-full-name "Arseniy Tsipenyuk"
        user-mail-address "arseniy.tsipenyuk@gmail.com")
#+END_SRC

* Theme
** Solarized for Emacs
   I'm a big fan of Solarized minus the font-size changes.
   #+BEGIN_SRC emacs-lisp
  (use-package solarized-theme
    :init
      ;; Avoid all font-size changes
      (setq solarized-height-minus-1 1.0)
      (setq solarized-height-plus-1 1.0)
      (setq solarized-height-plus-2 1.0)
      (setq solarized-height-plus-3 1.0)
      (setq solarized-height-plus-4 1.0)
    
      ;; larger font
      (set-face-attribute 'default nil :font "Ubuntu Mono 15" )
      (set-frame-font "Ubuntu Mono 18" nil t))

      ;; load theme
      (load-theme 'solarized-light t)
   #+END_SRC

** Additional functions
   Toggle between light and dark themes.
   #+BEGIN_SRC emacs-lisp
   (defun light ()
     "Activate a light color theme."
     (interactive)
     (load-theme 'solarized-light))
	
    (defun dark ()
      "Activate a dark color theme."
      (interactive)
      (load-theme 'solarized-dark))
   #+END_SRC

* Basic Interface Settings
These are setting that do not depend on packages and are built-in enhancements to the UI.
** Looks
*** Remove the startup screen
Use the =dashboard= replacement described further below.
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC

*** Disable menus and scrollbars
If you like using any of those, change =-1= to =1=.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
;;(scroll-bar-mode -1)
#+END_SRC
*** Disable bell
This is annoying, remove this line if you like being visually reminded of events.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC
*** Set UTF-8 encoding
#+BEGIN_SRC emacs-lisp 
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC
*** Highligh current line
=hl-line= is awesome! It's not very awesome in the terminal version of emacs though, so we don't use that.
Besides, it's only used for programming.
#+BEGIN_SRC emacs-lisp
  (when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC

** Functionality
*** TODO Disable backups and auto-saves
As of yet, they are disabled as in the UncleDavesEmacs. I recall
S.Chua describing how to create a separate backup folder and intend to
implement it in the future.

Change the values below from =nil= to =t= to turn on backups.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq auto-save-default nil)
#+END_SRC
*** Change yes-or-no questions into y-or-n questions
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

* Window Manager
** MacOs: focus frame in foreground


* Projectile
Projectile is an awesome project manager, mostly because it recognizes directories
with a =.git= directory as projects and helps you manage them accordingly.

** Enable projectile globally
This makes sure that everything can be a project.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
      (projectile-mode 1))
#+END_SRC

** Let projectile call make
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>") 'projectile-compile-project)
#+END_SRC

* Dashboard
This is your new startup screen, together with projectile it works in unison and
provides you with a quick look into your latest projects and files.
Change the welcome message to whatever string you want and
change the numbers to suit your liking, I find 5 to be enough.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :config
      (dashboard-setup-startup-hook)
      (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
      (setq dashboard-items '((recents  . 5)
                              (projects . 5)))
      (setq dashboard-banner-logo-title "Hello there!"))
#+END_SRC

* Modeline
The modeline is the heart of emacs, it offers information at all
times, it's persistent and verbose enough to gain a full understanding
of modes and states you are in.

Due to the fact that we attempt to use emacs as a desktop environment
replacement, and external bar showing the time, the battery percentage
and more system info would be great to have.  I have however abandoned
polybar in favor of a heavily modified modeline, this offers me more
space on the screen and better integration.

One modeline-related setting that is missing and is instead placed at
the bottom is =diminish=.
** Spaceline
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :config
    (require 'spaceline-config)
      (setq spaceline-buffer-encoding-abbrev-p nil)
      (setq spaceline-line-column-p nil)
      (setq spaceline-line-p nil)
      (setq powerline-default-separator (quote arrow))
      (spaceline-spacemacs-theme))
#+END_SRC

** No separator!
#+BEGIN_SRC emacs-lisp
  (setq powerline-default-separator nil)
#+END_SRC

** Cursor position
Show the current line and column for your cursor.  We are not going to
have =relative-linum-mode= in every major mode, so this is useful.
#+BEGIN_SRC emacs-lisp
  (setq line-number-mode t)
  (setq column-number-mode t)
#+END_SRC
** Clock
If you prefer the 12hr-format, change the variable to =nil= instead of =t=.

*** Time format
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (setq display-time-format "%H:%M - %d %B %Y")
#+END_SRC

*** Enabling the mode
This turns on the clock globally.
#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC

** Battery indicator
A package called =fancy-battery= will be used if we are in GUI emacs, otherwise the built in battery-mode will be used.
Fancy battery has very odd colors if used in the tty, hence us disabling it.
#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :config
      (setq fancy-battery-show-percentage t)
      (setq battery-update-interval 15)
      (if window-system
        (fancy-battery-mode)
        (display-battery-mode)))
#+END_SRC

** System monitor
A teeny-tiny system monitor that can be enabled or disabled at runtime, useful for checking performance
with power-hungry processes in ansi-term

symon can be toggled on and off with =Super + h=.
#+BEGIN_SRC emacs-lisp
  (use-package symon
    :ensure t
    :bind
    ("s-h" . symon-mode))
#+END_SRC
* The terminal
** Default shell: zsh
I don't know why this is a thing, but asking me what shell to launch every single
time I open a terminal makes me want to slap babies, this gets rid of it.
This goes without saying but you can replace bash with your shell of choice.
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/zsh")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

** Easy to remember keybinding
In loving memory of bspwm, Super + Enter opens a new terminal, old habits die hard.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<s-return>") 'ansi-term)
#+END_SRC

* Moving around emacs
One of the most important things about a text editor is how efficient you manage
to be when using it, how much time do basic tasks take you and so on and so forth.
One of those tasks is moving around files and buffers, whatever you may use emacs for
you /will/ be jumping around buffers like it's serious business, the following
set of enhancements aims to make it easier.

As a great emacs user once said:

#+BEGIN_QUOTE
Do me the favor, do me the biggest favor, matter of fact do yourself the biggest favor and integrate those into your workflow.
#+END_QUOTE
** a prerequisite for others packages
#+BEGIN_SRC emacs-lisp
  (use-package ivy)
#+END_SRC
** scrolling and why does the screen move
I don't know to be honest, but this little bit of code makes scrolling with emacs a lot nicer.
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC
** which-key and why I love emacs
In order to use emacs, you don't need to know how to use emacs.
It's self documenting, and coupled with this insanely useful package, it's even easier.
In short, after you start the input of a command and stop, pondering what key must follow,
it will automatically open a non-intrusive buffer at the bottom of the screen offering
you suggestions for completing the command, that's it, nothing else.

It's beautiful.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
      (which-key-mode))
#+END_SRC

** windows, panes and why I hate other-window
Some of us have large displays, others have tiny netbook screens, but
regardless of your hardware you probably use more than 2 panes/windows
at times, cycling through all of them with =C-c o= is annoying to say
the least, it's a lot of keystrokes and takes time, time you could
spend doing something more productive.

*** switch-window
This magnificent package takes care of this issue.
It's unnoticeable if you have <3 panes open, but with 3 or more, upon pressing =C-x o=
you will notice how your buffers turn a solid color and each buffer is asigned a letter
(the list below shows the letters, you can modify them to suit your liking), upon pressing
a letter asigned to a window, your will be taken to said window, easy to remember, quick to use
and most importantly, it annihilates a big issue I had with emacs. An alternative is =ace-window=,
however by default it also changes the behaviour of =C-x o= even if only 2 windows are open,
this is bad, it also works less well with =exwm= for some reason.
#+BEGIN_SRC emacs-lisp
(use-package switch-window
  :ensure t
  :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
        '("h" "t" "n" "s" "a" "o" "e" "u" "i"))
  :bind
    ([remap other-window] . switch-window))
#+END_SRC

*** Following window splits
After you split a window, your focus remains in the previous one.
This annoyed me so much I wrote these two, they take care of it.
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

** swiper is not quite for me
I could not get into swiper --- maybe in the future.
I am keeping it here as a reference.
#+BEGIN_SRC emacs-lisp
  ;;(use-package swiper
  ;;  :ensure t
  ;;  :bind ("C-s" . 'swiper))
#+END_SRC

** buffers and why I hate list-buffers
Another big thing is, buffers. If you use emacs, you use buffers, everyone loves them.
Having many buffers is useful, but can be tedious to work with, let us see how we can improve it.
*** Always murder current buffer
Doing =C-x k= should kill the current buffer at all times, we have =ibuffer= for more sophisticated thing.
#+BEGIN_SRC emacs-lisp
  (defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC
*** Kill buffers without asking for confirmation
Unless you have the muscle memory, I recommend omitting this bit, as you may lose progress for no reason when working.
#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC
*** Turn list-buffers into ibuffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC
*** close-all-buffers
It's one of those things where I genuinely have to wonder why there is no built in functionality for it.
Once in a blue moon I need to kill all buffers, and having ~150 of them open would mean I'd need to spend a few too many
seconds doing this than I'd like, here's a solution.

This can be invoked using =C-M-s-k=. This keybinding makes sure you don't hit it unless you really want to.
#+BEGIN_SRC emacs-lisp
  (defun close-all-buffers ()
    "Kill all buffers without regard for their origin."
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC

** line numbers and programming
Every now and then all of us feel the urge to be productive and write some code.
In the event that this happens, the following bit of configuration makes sure that 
we have access to relative line numbering in programming-related modes.
I highly recommend not enabling =linum-relative-mode= globally, as it messed up 
something like =ansi-term= for instance.
#+BEGIN_SRC emacs-lisp
  (use-package linum-relative
    :ensure t
    :config
      (setq linum-relative-current-symbol "")
      (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC

** ido 
Couldn't quite get into helm. Maybe some time in the future.
*** ido
#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)

  (use-package idomenu)
  (global-set-key (kbd "C-;") 'idomenu)
#+END_SRC

** avy and why it's the best thing in existence
Many times have I pondered how I can move around buffers even quicker.
I'm glad to say, that avy is precisely what I needed, and it's
precisely what you need as well.  In short, as you invoke one of avy's
functions, you will be prompted for a character that you'd like to
jump to in the /visible portion of the current buffer/.  Afterwards
you will notice how all instances of said character have additional
letter on top of them.  Pressing those letters, that are next to your
desired character will move your cursor over there.  Admittedly, this
sounds overly complicated and complex, but in reality takes a split
second and improves your life tremendously.

I like =M-s= for it, same as =C-s= is for moving by searching string, now =M-s= is moving by searching characters.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind
      ("M-s" . avy-goto-char))
#+END_SRC

** Rebind paragraph and buffer movement
The rebindings are at the end of the file, as they overwrite some of
the Org bindings.
* Minor conveniences
Emacs is at it's best when it just does things for you, shows you the
way, guides you so to speak.  This can be best achieved using a number
of small extensions. While on their own they might not be particularly
impressive. Together they create a nice environment for you to work
in.
** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor.
Unless you know its position, you can not move it efficiently. Every time you change
buffers, the current position of your cursor will be briefly highlighted now.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
      (beacon-mode 1))
#+END_SRC
** Configuration shortcuts
*** Visiting the configuration
Quickly edit =~/.emacs.d/config.org=
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

*** Reloading the configuration
You can also manually invoke =config-reload=.
#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    "Reloads ~/.emacs.d/config.org at runtime"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
  (global-set-key (kbd "C-c d") 'config-reload)
#+END_SRC

** Electric
If you write any code, you may enjoy this.
Typing the first character in a set of 2, completes the second one after your cursor.
Opening a bracket? It's closed for you already. Quoting something? It's closed for you already.

You can easily add and remove pairs yourself, have a look.
#+BEGIN_SRC emacs-lisp
(setq electric-pair-pairs '(
                           (?\{ . ?\})
                           (?\( . ?\))
                           (?\[ . ?\])
                           (?\" . ?\")
                           ))
#+END_SRC

And now to enable it
#+BEGIN_SRC emacs-lisp
;;(electric-pair-mode t)
#+END_SRC
I have tried it out and it just gets in my way.

** Expand region
A pretty simple package, takes your cursor and semantically expands
the region, so words, sentences, maybe the contents of some
parentheses, it's awesome, try it out.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-q" . er/expand-region))
#+END_SRC
** Fill to char
#+BEGIN_SRC emacs-lisp
  (defun fill-to-end (char)
    (interactive "cFill Character:")
    (save-excursion
      (end-of-line)
      (while (< (current-column) 80)
        (insert-char char))))
  
  (defun fill-short (char)
    (interactive "cFill Character:")
    (save-excursion
      (end-of-line)
      (while (< (current-column) 72)
        (insert-char char))))
#+END_SRC
** Backwards / Forwards in help-mode-map
#+BEGIN_SRC emacs-lisp
  (define-key help-mode-map (kbd "b") 'help-go-back)
  (define-key help-mode-map (kbd "f") 'help-go-forward)
#+END_SRC

** Hungry deletion
On the list of things I like doing, deleting big whitespaces is pretty close to the bottom.
Backspace or Delete will get rid of all whitespace until the next non-whitespace character is encountered.
You may not like it, thus disable it if you must, but it's pretty decent.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :config
      (global-hungry-delete-mode))
#+END_SRC
** Other frame shortcut
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-,") 'other-frame)
#+END_SRC

** Pdf-tools
Better pdf-browsing than docview.
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t)
  (pdf-tools-install)
#+END_SRC
** Prose mode
Single buffer, narrow view.
#+BEGIN_SRC emacs-lisp
    (require 'prose-mode)
#+END_SRC
** Rainbow
Mostly useful if you are into web development or game development.
Every time emacs encounters a hexadecimal code that resembles a color, it will automatically highlight
it in the appropriate color. This is a lot cooler than you may think.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init
      (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC
** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them,
especially lisp.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

#+END_SRC
** Reload buffer fontification
Sometimes the buffer just isn't fontified correctly. Here's how to fix it.
   #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-x C-$") 'font-lock-fontify-buffer)
   #+END_SRC

** Reconfiguring windows
   #+BEGIN_SRC emacs-lisp
   ;;----------------------------------------------------------------------------
;; Rearrange split windows
;;----------------------------------------------------------------------------
(defun split-window-horizontally-instead ()
  "Kill any other windows and re-split such that the current window is on the top half of the frame."
  (interactive)
  (let ((other-buffer (and (next-window) (window-buffer (next-window)))))
    (delete-other-windows)
    (split-window-horizontally)
    (when other-buffer
      (set-window-buffer (next-window) other-buffer))))

(defun split-window-vertically-instead ()
  "Kill any other windows and re-split such that the current window is on the left half of the frame."
  (interactive)
  (let ((other-buffer (and (next-window) (window-buffer (next-window)))))
    (delete-other-windows)
    (split-window-vertically)
    (when other-buffer
      (set-window-buffer (next-window) other-buffer))))

(global-set-key (kbd "C-x |") 'split-window-horizontally-instead)
(global-set-key (kbd "C-x _") 'split-window-vertically-instead)
#+END_SRC
** Revert buffer
Imported from [[https://emacs.stackexchange.com/questions/169/how-do-i-reload-a-file-in-a-buffer][this thread]].
https://emacs.stackexchange.com/questions/169/how-do-i-reload-a-file-in-a-buffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c r") 
    (lambda ()
      (interactive)
      (revert-buffer t t t)
      (message "buffer is reverted")))
#+END_SRC

** Show parens
I forgot about that initially, it highlights matching parens when the cursor is just behind one of them.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
** Subwords
Emacs treats camelCase strings as a single word by default, this changes said behaviour.
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC
** Zapping to char
A nifty little package that kills all text between your cursor and a selected character.
A lot more useful than you might think. If you wish to include the selected character in the killed region,
change =zzz-up-to-char= into =zzz-to-char=.
#+BEGIN_SRC emacs-lisp
  (use-package zzz-to-char
    :ensure t
    :bind ("M-z" . zzz-up-to-char))
#+END_SRC

* Kill ring
There is a lot of customization to the kill ring, and while I have not used it much before,
I decided that it was time to change that.
** Maximum entries on the ring
The default is 60, I personally need more sometimes.
#+BEGIN_SRC emacs-lisp
  (setq kill-ring-max 100)
#+END_SRC
** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most.
With a simple M-y you can now browse your kill-ring like browsing autocompletion items.
C-n and C-p totally work for this.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))

#+END_SRC


* Programming
  Minor, non-completion related settings and plugins for writing code.
** yasnippet
#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :config
        (use-package yasnippet-snippets
          :ensure t)
        (yas-reload-all))
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC
** company mode
I set the delay for company mode to kick in to half a second, I also make sure that
it starts doing its magic after typing in only 2 characters.
I prefer =C-n= and =C-p= to move around the items, so I remap those accordingly.

(sic) Not sure I get this -- AT. 
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 3))

  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous)
    (define-key company-active-map (kbd "SPC") #'company-abort))
#+END_SRC
** specific languages
Be it for code or prose, completion is a must.
As of yet, I only use =company= completion.

Each category also has additional settings.
*** c/c++
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)

  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
       (flycheck-clang-analyzer-setup)))

  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :ensure t)

  (use-package company-irony
    :ensure t
    :config
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-irony))))

  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC
*** python
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
  (add-hook 'python-mode-hook 'flycheck-mode)

  ;; use python3 by default
  (when (executable-find "ipython3")
    (setq python-shell-interpreter "ipython3"))

  (with-eval-after-load 'company
      (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-to-list 'company-backends 'company-jedi))

  (defun python-mode-company-init ()
    (setq-local company-backends '((company-jedi
				    company-etags
				    company-dabbrev-code))))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-hook 'python-mode-hook 'python-mode-company-init))
#+END_SRC
*** emacs-lisp
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "/usr/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))

  (use-package slime-company
    :ensure t
    :init
      (require 'company)
      (slime-setup '(slime-fancy slime-company)))
#+END_SRC
*** bash
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
  (add-hook 'shell-mode-hook 'flycheck-mode)
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
      (require 'company)
      (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC
*** julia 
**** TODO Setup company mode. Some references:
 - https://github.com/non-Jedi/lsp-julia
 - https://discourse.julialang.org/t/is-there-any-completion-plugin-for-emacs/14758
#+BEGIN_SRC emacs-lisp
  (use-package julia-mode)
  (use-package julia-repl)

  (add-hook 'julia-mode-hook 'yas-minor-mode)
  (add-hook 'julia-mode-hook 'flycheck-mode)

  (with-eval-after-load 'company
      (add-hook 'julia-mode-hook 'company-mode))
#+END_SRC

* Git integration
Countless are the times where I opened ansi-term to use =git= on something.
These times are also something that I'd prefer stay in the past, since =magit= is
great. It's easy and intuitive to use, shows its options at a keypress and much more.
** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
    :bind
    ("M-g" . magit-status))
#+END_SRC
* Remote editing
I have no need to directly edit files over SSH, but what I do need is a way to edit files as root.
Opening up nano in a terminal as root to play around with grubs default settings is a no-no, this solves that.

** Editing with sudo
Pretty self-explanatory, useful as hell if you use exwm.
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :bind
      ("s-e" . sudo-edit))
#+END_SRC
* Org
One of the absolute greatest features of emacs is called "org-mode".
This very file has been written in org-mode, a lot of other configurations are written in org-mode, same goes for
academic papers, presentations, schedules, blogposts and guides.
Org-mode is one of the most complex things ever, lets make it a bit more usable with some basic configuration.


Those are all rather self-explanatory.
** Common settings

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis " ")
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-export-with-smart-quotes t)
  (setq org-src-window-setup 'current-window)
  ;;(add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC
** Syntax highlighting for documents exported to HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t)
#+END_SRC
** Line wrapping
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
	    '(lambda ()
	       (visual-line-mode 1)))
#+END_SRC
** Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c '") 'org-edit-src-code)
#+END_SRC
** Easy-to-add emacs-lisp template
Hitting tab after an "<el" in an org-mode file will create a template for elisp insertion.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
	       '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC
** Exporting options
One of the best things about org is the ability to export your file to many formats.
Here is how we add more of them!

*** latex
#+BEGIN_SRC emacs-lisp
  (when (file-directory-p "/usr/share/emacs/site-lisp/tex-utils")
    (add-to-list 'load-path "/usr/share/emacs/site-lisp/tex-utils")
    (require 'xdvi-search))
#+END_SRC

* Diminishing modes
Your modeline is sacred, and if you have a lot of modes enabled, as you will if you use this config,
you might end up with a lot of clutter there, the package =diminish= disables modes on the mode line but keeps
them running, it just prevents them from showing up and taking up space.

*THIS WILL BE REMOVED SOON AS USE-PACKAGE HAS THE FUNCTIONALITY BUILT IN*

Edit this list as you see fit!
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :init
    (diminish 'which-key-mode)
    (diminish 'linum-relative-mode)
    (diminish 'hungry-delete-mode)
    (diminish 'visual-line-mode)
    (diminish 'subword-mode)
    (diminish 'beacon-mode)
    (diminish 'irony-mode)
    (diminish 'page-break-lines-mode)
    (diminish 'auto-revert-mode)
    (diminish 'rainbow-delimiters-mode)
    (diminish 'rainbow-mode)
    (diminish 'yas-minor-mode)
    (diminish 'flycheck-mode)
    (diminish 'helm-mode))
#+END_SRC
* Instant messaging
** rich presence for discord
Memes, but it's fun and tiny.
#+BEGIN_SRC emacs-lisp
  (use-package elcord
    :ensure t)
#+END_SRC
* Text manipulation
Collect self-made functions that make editing text easier.

** Mark-Multiple
This extension allows you to quickly mark the next occurence of a region and edit them all at once. 
I'm not sure I get how to use it, though. Maybe I will remove it later.
#+BEGIN_SRC emacs-lisp
  (use-package mark-multiple
    :ensure t
    :bind ("C-c q" . 'mark-next-like-this))
#+END_SRC
** Improved copy-word
And again, the same as above but we make sure to not delete the source word.
#+BEGIN_SRC emacs-lisp
  (defun at/copy-whole-word ()
    (interactive)
    (save-excursion
      (forward-char 1)
      (backward-word)
      (kill-word 1)
      (yank)))
  (global-set-key (kbd "C-c w c") 'at/copy-whole-word)
#+END_SRC

** Improved kill-word
Why on earth does a function called =kill-word= not .. kill a word.
It instead deletes characters from your cursors position to the end of the word,
let's make a quick fix and bind it properly.
#+BEGIN_SRC emacs-lisp
  (defun at/kill-inner-word ()
    "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
    (interactive)
    (forward-char 1)
    (backward-word)
    (kill-word 1))
  (global-set-key (kbd "C-c w k") 'at/kill-inner-word)
#+END_SRC
** Copy a line
Regardless of where your cursor is, this quickly copies a line.
#+BEGIN_SRC emacs-lisp
  (defun at/copy-whole-line ()
    "Copies a line without regard for cursor position."
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
        (point-at-bol)
        (point-at-eol)))))
  (global-set-key (kbd "C-c l c") 'at/copy-whole-line)
#+END_SRC

** Kill a line
And this quickly deletes a line.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l k") 'kill-whole-line)
#+END_SRC

** Copy file name to clipboard
#+BEGIN_SRC emacs-lisp
  ;; Copy the current buffer file name
  (defun copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))
  (global-set-key (kbd "C-c C-f") 'copy-file-name-to-clipboard)
#+END_SRC
** Delete file / Rename file
#+BEGIN_SRC emacs-lisp
;; Delete the current file
  (defun delete-this-file ()
    "Delete the current file, and kill the buffer."
    (interactive)
    (unless (buffer-file-name)
      (error "No file is currently being edited"))
    (when (yes-or-no-p (format "Really delete '%s'?"
                               (file-name-nondirectory buffer-file-name)))
      (delete-file (buffer-file-name))
      (kill-this-buffer)))
  
  ;; Rename the current file
  (defun rename-this-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (unless filename
        (error "Buffer '%s' is not visiting a file!" name))
      (progn
        (when (file-exists-p filename)
          (rename-file filename new-name 1))
        (set-visited-file-name new-name)
        (rename-buffer new-name))))
#+END_SRC

** Add new lines with C-n
#+BEGIN_SRC emacs-lisp
  (setq next-line-add-newlines t)
#+END_SRC

** Prohibit tab insertion
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC
** Loading custom keyboard layout
My main layout is pdv. 
On top of that I use a modified version of the russian typewriter.
If I use =(set-input-method 'russian-typewriter)=, everything
will be messed up (as Emacs wolud convert =qwerty= to russian typewriter).
I have created a file =pdv-to-rut.el.gz= with an appropriate conversion.
This file is loaded here, and layout switchers are provided.
#+BEGIN_SRC emacs-lisp
  (require 'pdv-to-rut)

  (defun at/set-input-method-pdv-to-rut ()
    "Set input method to pdv-to-rut"
    (interactive)
    (set-input-method 'pdv-to-russian-typewriter))

  (defun at/set-input-method-ucs ()
    "Set input method to ucs"
    (interactive)
    (set-input-method 'ucs))

  (global-set-key (kbd "s-*") 'at/set-input-method-ucs)
  (global-set-key (kbd "s-)") 'at/set-input-method-pdv-to-rut)
#+END_SRC

** New line below / above
#+BEGIN_SRC emacs-lisp
  ;; Insert new line below current line and move cursor to new line
  ;; it will also indent newline
  (global-set-key (kbd "<C-return>")
                  (lambda ()
                    (interactive)
                    (end-of-line)
                    (newline-and-indent)))
  ;; Insert new line above current line and move cursor to previous line (newly inserted line)
  ;; it will also indent newline
  (global-set-key (kbd "<C-S-return>")
                  (lambda ()
                    (interactive)
                    (previous-line)
                    (end-of-line)
                    (newline-and-indent)))
#+END_SRC
* Rebinding over Org-mode
** Rebind paragraph and buffer movement
(I use programmer Dvorak layout.)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-,") 'beginning-of-buffer)
  (global-set-key (kbd "C-.") 'end-of-buffer)
  (global-set-key (kbd "C-{") 'backward-paragraph)
  (global-set-key (kbd "C-}") 'forward-paragraph)
#+END_SRC
** Default browser and Chrome
I keep a Google Chrome keybinding "just in case".
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "qutebrowser")

  (defun org-open-at-point-with-chrome ()
    (interactive)
    (let ((browse-url-browser-function 'browse-url-chrome))
      (org-open-at-point )))
  
  (define-key org-mode-map (kbd "C-c C-;") 'org-open-at-point-with-chrome)
#+END_SRC

* Further work
** TODO Integrate setup to .dotfiles bundle, e.g., as [[https://medium.com/@webprolific/getting-started-with-dotfiles-43c3602fd789][here]]






